# Файловая система: Write-up

Подключаемся и видим шелл:

```shell
/$ ls
Type  UID  Your perms  Public perms  Filename
dir     0  r-          r-            home
```

Упс, это явно не bash и явно не Linux.

```shell
/$ help
Supported commands:
help                            Print this help
exit                            Quit session
resys                           Reset filesystem to backup
cd <path>                       Change working directory
ls [<path>]                     List files in directory
cat <path>                      Print file contents
stat <path>                     Print file metadata
find [<path>]                   Recursively list directory
grep <str> <path>               Search files for substring
write <path> <data>             Overwrite file with hex data
mkdir <path>                    Create directory
unlink <path>                   Delete file/directory
df                              Show free space
whoami                          Show current user
/$ whoami
guest (UID 128)
```

Давайте посмотрим, что тут вообще есть.

```shell
/$ cd home
/home$ ls
Type  UID  Your perms  Public perms  Filename
dir   128  rw          r-            guest
dir   129  r-          r-            purplesyringa
/home$ ls guest
Type  UID  Your perms  Public perms  Filename
/home$ ls purplesyringa
Type  UID  Your perms  Public perms  Filename
file  129  r-          r-            sticker.webp
file  129  --          --            flag.txt
dir   129  r-          r-            vfs
/home$ ls purplesyringa/vfs
Type  UID  Your perms  Public perms  Filename
file  129  r-          r-            main.rs
file  129  r-          r-            vfs
```

У нас есть аж целая одна директория, в которую можно писать (`/home/guest`), а также несколько файлов: [стикер](vfs/sticker.webp), флаг (без прав чтения), какой-то [код на Rust](vfs/src/main.rs) и собранный бинарник. Текстовые файлы можно прочитать с помощью команды `cat`. Цель, видимо, состоит в том, чтобы прочитать файл `/home/purplesyringa/flag.txt`. С бинарными чуть сложнее, но сохранив вывод в файл и обрезав из начала и конца промпт шелла, их можно также восстановить (впрочем, для решения задания это не обязательно).

Итак, шелл и драйвер файловой системы написаны на Rust, причем исходный код у нас есть. В комментариях в начале кода описан формат хранения файловой системы. Из него следует, что вся файловая система разбивается на блоки по 4096 байт, директории, файлы и свободные блоки хранятся как связные списки, а вся адресация проводится по номерам блоков. Это, конечно, не очень эффективно, но для игрушечной файловой системы в самый раз. Качество кода оставляет желать лучшего, но в целом никакие очевидные ошибки в глаза не бросаются.

Разве что странно, что к файловой системе можно одновременно подключиться несколько раз, она при этом будет общей, а мьютексов нигде нет. Добиться состояния гонки по сети сложно, но не невозможно, если воспользоваться трюком. В реализации, например, команды `cat` есть следующий код:

```rust
for chunk in iterator {
	let chunk = match chunk {
	    Ok(chunk) => chunk,
	    Err(error) => {
	        println!("cat: {error:?}");
	        return Ok(());
	    }
	};
	io::stdout().write_all(&chunk)?;
}
```

Вызов функции `write_all` ждет, пока по сокету будет доставлен весь аргумент, и возвращает управление лишь тогда. С медленным интернетом `write_all` будет работать долго, а значит, в этот момент можно сделать какое-то действие. Например, если удалить файл во время чтения его `cat`'ом, произойдет следующее: текущий чанк закончит вывод в stdout, `<FileIterator as Iterator>::next` посмотрит на поле `self.block_index`, прочитает этот блок и выведет его, и так далее. Но поскольку файл был удален, то `self.block_index` будет указывать на освобожденный блок, и дальнейший проход по связному списку обойдет остальные освобожденные блоки, поскольку так устроен формат хранения файловой системы.

Решить задачу это не помогает, но дает намек на то, что подобный метод можно доработать. Во-первых, можно не сидеть на медленном интернете, а просто не вычитывать данные из сокета. Во-вторых, подобная проблема с обращением к свободной памяти случается не только с файлами, но и с директориями. Если мы создадим директорию, начнем ее читать, на ходу удалим, а потом создадим файл, то только что освобожденные блоки директории будут переиспользованы под файл. А значит, записав в файл какие-то бинарные данные, мы добьемся того, что они будет проинтерпретированы как внутренние структуры файловой системы.

Эксплоит выглядит так. Создаем директорию на 171 файл, чтобы она занимала два блока. В первый из этих файлов записываем много раз повторенную строку `ugra` и запускаем на директории рекурсивный `grep` по подстроке `ugra`. В этот момент начинает вычитываться и выводиться на экран первый файл, и мы останавливаем получение ввода. Через другое подключение к той же файловой системе удаляем 171-й файл, при этом освобождается второй блок директории. Создаем еще один файл где-нибудь в другом месте — он займет только что освобожденный блок и при продолжении работы `grep` проинтерпретируется как блок директории. В этот файл записываем фейковую ссылку на владеемый UID 128 файл с блоком 14 (как показывает `stat /home/purplesyringa/flag.txt`, именно в этом блоке лежит флаг) с любым именем. Продолжаем работу `grep`. Когда тот дойдет до второго блока и перейдет в `flag.txt`, выведется флаг.

Автоматизированную версию похожего решения можно найти в файле [solve.py](solve.py).

Флаг: **ugra_i_hope_you_enjoyed_it_zw5gzvge7ibm**
