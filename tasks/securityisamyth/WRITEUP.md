# Ешь богатых!: Write-up

Из кода [prover.py](app/server/attachments/prover.py) понятно, что нас просят решить [задачу дискретного логарифмирования](https://en.wikipedia.org/wiki/Discrete_logarithm). Судя по коду [verifier.py](app/server/attachments/verifier.py), простое число используется большое, а все остальные параметры задачи генерируются случайно, так что вряд ли эту задачу можно решить алгоритмически. Придется искать дыру в протоколе.

Web-сервер при заходе на страницу выдает текст `This is a ZKP server. Please use prover.py to communicate with the backend.`. ZKP — это [Zero-Knowledge Proof](https://en.wikipedia.org/wiki/Zero-knowledge_proof), т.е. доказательство с нулевым разглашением. Идея в том, что мы хотим доказать знание какого-то математического объекта (например, числа) так, чтобы никто не узнал, как же этот объект конкретно выглядит (например, чему именно равно число). Это дает некоторую надежду на то, что мы сможем убедить систему, что знаем дискретный логарифм, при этом его не зная.

В статье Википедии о ZKP есть отдельный раздел про [дискретный логарифм](https://en.wikipedia.org/wiki/Zero-knowledge_proof#Discrete_log_of_a_given_value), в которой описана атака на алгоритм. Не будем повторять статью лишний раз, приведем лишь основную идею атаки в терминах, используемых в этом задании. Если мы как-то узнаем, чему будет равен `choice` на каждом шагу *до* того, как нужно будет отправить массив `cs`, мы сможем подобрать значения `c` так, чтобы все `assert`'ы прошли несмотря на то, что решить уравнение мы не можем:

```python
if choice == 0:
    # Verifier asked for (x+r) mod (p-1)
    assert c * self.y % P == gmpy2.powmod(self.g, answer, P)
else:
    # Verifier asked for r
    assert c == gmpy2.powmod(self.g, answer, P)
```

Если мы знаем, что на очередном шаге будет `choice == 1`, то в качестве `c` можно подставить `1`, а в качестве `answer` — `0`. Тогда `assert`, очевидно, пройдет. А если `choice == 0`, то в качестве `answer` тоже можно взять `1`, а вместо `c` подставить обратное к `y` под модулю `P`.

Но как узнать массив `choices` *до* отправки `cs`? Протокол это не позволяет, попытки посылать запросы в обход тоже ни к чему не приводят.

Но... для генерации параметров используется небезопасный рандом. Так ни в коем случае нельзя делать, а тут — сделали. Мда.

Проблема в том, что случайные числа в криптографии должны быть непредсказуемыми, а здесь это не так. Есть много библиотек для предсказывания значений генератора псевдослучайных чисел, используемого в Python, исходя из старых значений, например [mt19937predictor](https://github.com/kmyk/mersenne-twister-predictor). Для точного предсказания требуется 624 32-битных чисел, т.е. 19968; перед генерацией `choices` как раз генерируется два раза по 16384 бита, так что публичных данных должно более чем хватать.

В псевдокоде мы хотим сделать что-то в духе:

```python
predictor = MT19937Predictor()
# get-parameters
predictor.setrandbits(g, 16384)
predictor.setrandbits(y, 16384)
choices = predictor.getrandbits(32)
choices = [(choices >> i) & 1 for i in range(32)]
cs = [pow(y, -1, p) if choice == 0 else 1 for choice in choices]
# announce-cs
answers = [0] * 32
# answer-choices
```

Такое решение, будучи [дописанным](solve.py), действительно проходит все 32 итерации, после чего выдает флаг.

Флаг: **ugra_g00d_1uck_w1th_y0ur_run4w4y_n0w_f79nka8pzfqm**
